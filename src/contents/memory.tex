\section{SGX Memory Organization}
\label{sec:memory}

This section provides an overview of the memory model and  data structures used
by an enclave.




\subsubsection{The Enclave Page Cache Map (EPCM)}

% Enclave Page Cache Map (EPCM): SDM S 37.5.1, SDM S 38.19
% SECINFO.FLAGS: SDM S 38.11.1
% PAGE_TYPE Field Definition: SDM S 38.11.2

SGX relies on the system software to set up each enclave's page tables
according to the enclave developer's design, but does not trust the system
software to do so. An SGX-enabled CPU prevents direct active address
translation attacks using the \textit{Enclave Page Cache Map}~(EPCM), which has
an entry containing the security metadata shown in
Table~\ref{fig:sgx_epcm_entry}
for each EPC page.



\begin{table}[hbt]
  \centering
  \begin{tabularx}{\columnwidth}{| l | r | X |}
  \hline
  \textbf{Field} & \textbf{Bits} & \textbf{Description}\\
  \hline
  VALID & 1 & 0 for un-allocated EPC pages \\
  \hline
  BLOCKED & 1 & page is being evicted (\S~\ref{sec:sgx_ewb})\\
  \hline
  R & 1 & allow reads by enclave code\\
  \hline
  W & 1 & allow writes by enclave code\\
  \hline
  X & 1 & allow execution of code inside the page, inside enclave\\
  \hline
  PT & 8 & page type (\S~\ref{sec:key_structures})\\
  \hline
  ADDRESS & 48 & the virtual address used to access this page\\
  \hline
  EID & 64 & identifies the enclave owning the page\\
  \hline
  \end{tabularx}
  \caption{
    The fields in an EPCM entry.
  }
  \label{fig:sgx_epcm_entry}
\end{table}

% Access Control Requirements: SDM S 38.3

SGX's main weapon against memory mapping attacks is the ENCLAVEADDRESS metadata
field, which contains the expected virtual address (\S~\ref{sec:segments}) used
to access the page. The expected virtual address must be specified when a page
is allocated, and cannot be changed until the page is freed.

When an address translation (\S~\ref{sec:paging}) result is the physical
address of an EPC page, the CPU ensures\footnote{A mismatch triggers a general
protection fault (\#GP, \S~\ref{sec:faults}).} that the virtual address given
to the address translation process matches the expected virtual address
recorded in the page's EPCM entry, as shown in
Figure~\ref{fig:sgx_tlb_miss_checks}. This prevents the system software, which
manages the page tables and EPT, from modifying an enclave's virtual address
space in a manner that is inconsistent with the enclave author's expectations.


Figure~\ref{fig:sgx_tlb_miss_checks}

\begin{figure}[hbt]
  \centering
  \includegraphics[width=85mm]{figures/sgx_tlb_miss_checks.pdf}
  \caption{
    An enclave's EPC pages are accessed using a dedicated region in the
    enclave's virtual address space, called ELRANGE. The rest of the virtual
    address space maps the host application's memory.
  }
  \label{fig:sgx_tlb_miss_checks}
\end{figure}

% Security Information (SECINFO): SDM S 38.11, S 38.11.{1,2}

The EPCM entry for a page has three access protection bits that must be set to
1 to allow a page to be read (R), written to (W) and executed (X) by enclave
code. When an address translation result points to an EPC page, the access
protection bits in the page's EPCM entry influence the related bits in the
page's TLB entry. For example, if X is 0, the XD bit (\S~\ref{sec:paging}) is
set in the page's TLB entry.

Table~\ref{fig:sgx_pt_values} shows currently defined types. The EPC pages that
store an enclave's code or data have their type set to \textit{regular}
(PT\_REG in the Intel documentation). Each page that is dedicated to an SGX key
data structure has its EPCM entry's type set to the kind of data structure
stored in the page. An EPC page's type is set when the page is allocated, and
is immutable throughout the page's lifetime.

\begin{table}[hbt]
  \centering
  \begin{tabularx}{\columnwidth}{| l | l | X |}
  \hline
  \textbf{Type} & \textbf{Created by} & \textbf{Description}\\
  \hline
  PT\_REG & \texttt{EADD} & enclave code / data \\
  \hline
  PT\_SECS & \texttt{ECREATE} & SECS (\S~\ref{sec:sgx_secs}) \\
  \hline
  PT\_TCS & \texttt{EADD} & TCS (\S~\ref{sec:sgx_tcs}) \\
  \hline
  PT\_VA & \texttt{EPA} & VA (\S~\ref{sec:sgx_va}) \\
  \hline
  \end{tabularx}
  \caption{Values of the PT (page type) field in an EPCM entry.}
  \label{fig:sgx_pt_values}
\end{table}





\subsection {The Implementation of EPC Protection}

The memory controller is
integrated on the CPU die (see Figure~\ref{fig:cpu_die}), so it can be trusted
to prevent devices attached to the system bus from performing DMA transfers
to/from the PRM.

System software manages physical memory by directly modifying the contents of
page tables and EPTs (\S~\ref{sec:paging}), and is responsible for performing
TLB shootdowns (\S~\ref{sec:tlbs}) to ensure that the state not covered by
cache coherence \S~\ref{sec:cache_coherence} is synchronized across logical
processors. If the system software does not perform TLB shootdowns correctly,
application software can experience inconsistent views of memory.

In the context of SGX, an incorrect TLB shootdown can can result in having an
EPC page simultaneously accessible by two different enclaves, which would
compromise the SGX security guarantees. Therefore, the SGX instructions used
for EPC management ensure that the system software performs TLB shootdowns for
the entries that represent EPC pages.


% PRMRR documented in HASP papers and both SGX manuals, completely removed from
% SDM. It still exists in Coreboot. Couldn't find other Skywell code.
The SGX manual states that the EPC (the memory used to store enclave data) can
only be set up as UC or WB. While no further explanation is provided, we assume
that the UC option was provided in order to attempt to mitigate against some
cache-timing attacks.


Having ELRANGE follow the memory type range constraints provides a cheap way to
verify if a virtual address belongs to the address, in hardware. This comes in
handy when EENTER has to disable all the hardware breakpoints inside ELRANGE.


% Access Control Requirements: SDM S 38.3

Pages that store key SGX structures cannot be accessed directly, even by the
code executing inside their enclaves. Furthermore, the SGX instructions that
operate on SGX data structures check the EPCM type fields of their inputs
against the expected types. This type system prevents software from
intentionally or accidentally corrupting the key SGX data structures.

The type-based access restrictions have the desirable side-effect of hiding the
contents of the EPC pages holding key SGX structures from software, so the
internal layout of any key data structure can change across new CPU revisions.
Software cannot access the key structures in EPC, so it cannot become dependent
on a specific processor's implementation details.

The SGX documentation does specify a software-visible layout for each key data
structure. This layout is used by the non-EPC page used to initialize the key
data structure when it is created. Therefore, new CPU revisions must preserve
the ability to initialize the key data structures from the less flexible
software-visible layout.


\subsection {Page Eviction Security}

The most obvious attack is prevented by having the MAC cover the contents of
the evicted EPC page, so the untrusted OS cannot modify the data in the page
while it is stored in untrusted DRAM. The MAC also covers the metadata that
makes up the EPCM entry, which prevents the more subtle attacks described
below.

The enclave ID (EID) field is covered by the MAC tag, so the OS cannot evict an
EPC page belonging to one enclave, and assign the page to a different enclave
when it is loaded back into the EPC. If EID was not covered by authenticity
guarantees, a malicious OS could read any enclave's data by evicting an EPC
page belonging to the victim enclave, and loading it into a malicious enclave
that would copy the page's contents to untrusted DRAM.

The virtual address (LINADDR) field is covered by the MAC tag, so the OS cannot
modify the virtual memory layout of an enclave by evicting an EPC page and
specifying a different LINADDR when loading it back. If LINADDR was not covered
by authenticity guarantees, a malicious OS could perform the exact attack shown
in Figure~\ref{fig:swap_mapping_attack} and described in
\S~\ref{sec:page_swapping_attacks}.

The page access permission flags (R, W, X) are also covered by the MAC tag.
This prevents the OS from changing the access permission bits in a page's EPCM
entry by evicting the page and loading it back in. If the permission flags were
not covered by authenticity guarantees, the OS could use the ability to change
EPCM access permissions to facilitate exploiting vulnerabilities in enclave
code. For example, exploiting a stack overflow vulnerability is generally
easier if OS can make the stack pages executable.

The nonce stored in the VA slot is also covered by the MAC. This prevents the
OS from mounting a replay attack that reverts the contents of an EPC page to an
older version. If the nonce would not be covered by integrity guarantees, the
OS could evict the target EPC page at different times $t_1$ and $t_2$ in the
enclave's life, and then provide the \texttt{EWB} outputs at $t_1$ to the
\texttt{ELDU} / \texttt{ELDB} instruction. Without the MAC verification, this
attack would successfully revert the contents of the EPC page to its version
at $t_1$.

While replay attacks look relatively benign, they can be quite devastating when
used to facilitate double spending.
