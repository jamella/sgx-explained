\section{Security Background}
\label{sec:security_background}

Most systems rely on some cryptographic primitives for security. Unfortunately,
these primitives have many assumptions, and building a secure system on top of
them is a highly non-trivial endeavor. It follows that a system's security
analysis should be particularly interested in what cryptographic primitives are
used, and how they are integrated into the system.

\S~\ref{sec:crypto_primitives} and \S~\ref{sec:crypto_constructs} lay the
foundations for such an analysis by summarizing the primitives used by the
secure architectures that we are interested in, and by describing the most
common constructs built using these primitives.
\S~\ref{sec:generic_software_attestation} builds on these concepts and
describes software attestation, which is the most popular method for
establishing trust in a secure architecture.

Having looked at the cryptographic foundations for building secure systems, we
turn our attention to the attacks that secure architecture have to withstand.
Asides from forming a security checklist for architecture design, these attacks
build intuition that helps understand design decisions in the architectures
that we are interested in.

The attacks that can be performed on a computer system are broadly classified
into physical attacks and software attacks. In \textit{physical attacks}, the
attacker takes advantage of a system's physical implementation details to
perform an operation that bypasses the limitations set by the computer
system's software abstraction layers. In contrast, \textit{software attacks}
are performed solely by executing software on the victim computer.
\S~\ref{sec:physical_attacks} summarizes the main types of physical attacks.

The distinction between software and physical attacks is particularly relevant
in cloud computing scenarios, where gaining software access to the computer
running a victim's software can be accomplished with a credit card backed by
modest funds~\cite{ristenpart2009colocation}, whereas physical access is a
more difficult prospect that requires trespass, coercion, or social engineering
on the cloud provider's employees.

However, the distinction between software and physical attacks is blurred by
the attacks presented in \S~\ref{sec:device_attacks}, which exploit
programmable peripherals connected to the victim computer's bus in order to
carry out actions that are normally associated with physical attacks.

While the vast majority of software attacks exploit a bug in a software
component, there are a few attack classes that deserve attention from
architecture designers. Memory mapping attacks, described in
\S~\ref{sec:address_translation_attacks}, become a possibility on architectures
where the system software is not trusted. Cache timing attacks, summarized in
\S~\ref{sec:cache_timing} exploit microarchitectural behaviors that are
completely observable in software, but dismissed by the security analyses of
most systems.

\input{contents/security/crypto_primitives.tex}
\input{contents/security/crypto_constructs.tex}
\input{contents/security/attestation.tex}
\input{contents/security/physical.tex}
\input{contents/security/privileged_sw.tex}
\input{contents/security/device_sw.tex}
\input{contents/security/memory_mapping.tex}
\input{contents/security/cache_timing.tex}
