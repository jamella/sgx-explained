\subsection{Cache Timing Attacks}
\label{sec:cache_timing}

% TODO: Figure out how to mention MSR's attacks that collect page fault
%       addresses. \cite{xu2015pagefaults}

Unfortunately, caches create a dependency between the location of a memory
access and the time it takes to perform the access. A cache miss requires
at least one memory access to the next level cache, and might require a second
memory access if a write-back occurs. The related work presented in
\cite{banescu2011cache} shows that it is practical to use the timing
differences between hits and misses to learn the memory access patterns of a
target thread, as long as an attacker thread shares a cache with the target
thread. The target's memory access patterns, in turn, can reveal private
information, such as whether certain bits in an encryption key are set or not.


Cache timing attacks~\cite{banescu2011cache} are a powerful class of software
attacks that can be mounted entirely by application
(ring 3, \S~\ref{sec:rings}) code. The attacker software measures the latency
of accesses to its own memory in order to determine whether the accesses caused
misses in a cache that is shared with a victim program. The memory accesses are
carefully chosen to reveal the memory access pattern of the victim program.
Cache timing attacks do not access the victim's memory directly, so they are
\emph{not} prevented by the address translation-based protections
(\S~\ref{sec:paging}) implemented in today's kernels and hypervisors.

Unfortunately, a cache timing attack can take advantage of the fact that the
LLC is inclusive and shared among CPU cores (\S~\ref{sec:cache_coherence}).
This allows an attacker thread to monitor a victim thread that runs on a core
in the same CPU die. The attacker can evict lines in the target core's cache by
filling up the L3 cache, and then probe the L3 cache to find out when the
target causes cache evictions.  The evicted lines disclose some of the bits in
the memory addresses accessed by the victim.

Cache timing attacks are known to retrieve cryptographic keys used by
AES~\cite{bonneau2006aes}, RSA~\cite{brumley2005rsa},
Diffie-Hellman~\cite{kocher1996timing}, and elliptic-curve
cryptography~\cite{brumley2011ecc}.
Early attacks required access to the victim's CPU core, but more sophisticated
recent attacks~\cite{yarom2013llctiming, liu2015llctiming} are able to use the
last-level cache (LLC), which is shared by all the cores on a CPU. Recently,
cache-timing attacks were demonstrated to be mountable via JavaScript code in a
page visited by a Web browser~\cite{oren2015jstiming}.

Given this pattern of vulnerabilities, ignoring cache timing attacks is
dangerously similar to ignoring the string of demonstrated attacks which led to
the deprecation of SHA-1~\cite{nist2014sha1policy, google2014sha1deprecation,
microsoft2014sha1deprecation}.

Alarmingly, {\em cache timing attacks require only unprivileged software
running on the victim's host computer}, and do not rely on any physical
access to the machine.

Some MSRs are also
exposed by instructions accessible to applications. For example, applications
can read the time-stamp counter with the \texttt{RDTSC} and \texttt{RDTSCP},
which are very useful for benchmarking and optimizing software, but also for
mounting timing attacks.

The high level of resource sharing introduced by hyper-threading introduces a
security vulnerability. Software running on one logical processor can use the
high-resolution performance counter (\texttt{RDTSCP},
\S~\ref{sec:address_spaces}) \cite{petters1999making} to get information about
the instructions and memory access patterns of another piece of software that
is executed on the other logical processor on the same core.

Out-of-order execution (\S~\ref{sec:out_of_order}) can introduce noise in cache
timing attacks. First, memory accesses may not be performed in program order,
which can impact the lines selected by the cache eviction algorithms. Second,
out-of-order execution may result in cache fills that do not correspond to
executed instructions. For example, a load that follows a faulting instruction
may be scheduled and executed before the fault is detected. Memory prefetching
adds further noise to cache timing attacks, as the attacker may observe cache
fills that don't correspond to instructions in the victim code, even when
accounting for speculative execution.

Our analysis of SGX concludes that it is vulnerable to cache timing attacks,
which can be used to obtain high-resolution memory access patterns for the
software running inside an SGX enclave.
