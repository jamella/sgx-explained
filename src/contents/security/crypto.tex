\subsection{Cryptographic Primitives}

This section overviews the cryptosystems used by secure architectures. We are
interested in cryptographic primitives that guarantee privacy, integrity, and
freshness, and we treat these primitives as black boxes, focusing on their use
in larger systems. \cite{katz2014crypto} covers the mathematics behind
cryptography, while \cite{ferguson2011crypto} covers the topic of building
systems out of cryptographic primitives.

A message whose \textit{privacy} is protected can be transmitted over an
insecure medium without an adversary being able to obtain the information in
the message. When \textit{integrity} protection is used, the receiver is
guaranteed to either obtain a message that was transmitted by the sender, or to
notice that an attacker tampered with the message's content.

When multiple messages get transmitted over an untrusted medium, a
\textit{freshness} guarantee assures the receiver that she will obtain the
latest message coming from the sender, or will notice an attack. A freshness
guarantee is stronger than the equivalent integrity guarantee, because the
latter does not protect against \textit{replay attacks} where the attacker
replaces a newer message with an older message coming from the same sender.

The following example further illustrates these concepts. Suppose Alice is a
wealthy investor who wishes to either \textsc{buy} or \textsc{sell} an item
every day. Alice cannot trade directly, and must relay her orders to her
broker, Bob, over a network connection owned by Eve.

A communication system with privacy guarantees would prevent Eve from
distinguishing between a \textsc{buy} and a \textsc{sell} order, as illustrated
in Figure~\ref{fig:privacy_attack}. Without privacy, Eve would know Alice's
order before it is is placed by Bob, so Eve would presumably gain a financial
advantage at Alice's expense.

\begin{figure}[hbt]
  \centering
  \includegraphics[width=85mm]{figures/privacy_attack.pdf}
  \caption{
    In a privacy attack, Eve sees the message sent by Alice to Bob and can
    understand the information inside it. In this case, Eve can tell that the
    message is a \textbf{buy} order, and not a \textbf{sell} order.
  }
  \label{fig:privacy_attack}
\end{figure}

A system with integrity guarantees would prevent Eve from replacing Alice's
message with a false order, as shown in Figure~\ref{fig:integrity_attack}. In
this example, without integrity guarantees, Eve could replace Alice's message
with a \textsc{sell-everything} order, and buy Alice's assets at a very low
price.

\begin{figure}[hbt]
  \centering
  \includegraphics[width=85mm]{figures/integrity_attack.pdf}
  \caption{
    In an integrity attack, Eve replaces Alice's message with her own. In this
    case, Eve sends Bob a \textbf{sell-everything} order.
    understand the information inside it. In this case, Eve can tell that the
    message is a \textbf{buy} order, and not a \textbf{sell} order.
  }
  \label{fig:integrity_attack}
\end{figure}

Last, a communication system that guarantees freshness would ensure that Eve
cannot perform the replay attack pictured in Figure~\ref{fig:freshness_attack},
where she would replace Alice's message with an older message. Without
freshness guarantees, Eve could mount the following attack, which bypasses
both privacy and integrity guarantees. Over a few days, Eve would copy and
store Alice's messages from the network. When an order would reach Bob, Eve
would observe the market and determine if the order was \textsc{buy} or
\textsc{sell}. After building up a database of messages labeled \textsc{buy} or
\textsc{sell}, Eve would replace Alice's message with an old message of her
choice.

\begin{figure}[hbt]
  \centering
  \includegraphics[width=85mm]{figures/integrity_attack.pdf}
  \caption{
    In a freshness attack, Eve replaces Alice's message with a message that she
    sent at an earlier time. In this example, Eve builds a database of labeled
    messages over time, and is able to send Bob her choice of a \textsc{buy} or
    a \textsc{sell} order.
  }
  \label{fig:freshness_attack}
\end{figure}


\subsubsection{Cryptographic Keys}

All cryptographic primitives that we describe here rely on \textit{keys}, which
are small pieces of information that must only be disclosed according to
specific rules. A large part of a system's security analysis focuses on
ensuring that the keys used by the underlying cryptographic primitives are
produced and handled according to the primitives' assumptions.

Each cryptographic primitive has an associated \textit{key generation
algorithm} that uses random data to produce a unique key. The random data is
produced by a \textit{cryptographically strong pseudo-random number generator}
(CSPRNG) that expands a small amount of \textit{random seed} data into a much
larger amount of data, which is computationally indistinguishable from true
random data. The random seed must be obtained from a true source of randomness
whose output cannot be predicted by an adversary, such as the least significant
bits of the temperature readings coming from a hardware sensor.

\textit{Symmetric key} cryptography requires that all the parties in the system
establish a shared \textit{secret key}, which is usually referred to as ``the
key''. Typically, one party executes the key generation algorithm and securely
transmits the resulting key to the other parties, as illustrated in
Figure~\ref{fig:symmetric_key_generation}. The channel used to
distribute the key must provide privacy and integrity guarantees, which is a
non-trivial logistical burden. The symmetric key primitives mentioned here do
not make any assumption about the key, so the key generation algorithm simply
grabs a fixed number of bits from the CSPRNG.

\begin{figure}[hbt]
  \centering
  \includegraphics[width=87mm]{figures/symmetric_key_generation.pdf}
  \caption{
    In symmetric key cryptography, a secret key is shared by the parties that
    wish to communicate securely.
  }
  \label{fig:symmetric_key_generation}
\end{figure}

The salient feature of \textit{asymmetric key} cryptography is that it does not
require a private channel for key distribution. Each party executes the key
generation algorithm, which produces a \textit{private key} and a
\textit{public key} that are mathematically related. Each party's public key
is distributed to the other parties over a channel with integrity guarantees,
as shown in Figure~\ref{fig:asymmetric_key_generation}.
Asymmetric key primitives are more flexible than their symmetric key
counterparts, but are more complicated and consume more computational
resources.

\begin{figure}[hbt]
  \centering
  \includegraphics[width=87mm]{figures/asymmetric_key_generation.pdf}
  \caption{
    An asymmetric key generation algorithm produces a private key and an
    associated public key. The private key is held confidential, while the
    public key is given to any party who wishes to securely communicate with
    the private key's holder.
  }
  \label{fig:asymmetric_key_generation}
\end{figure}


\subsubsection{Privacy}

Many cryptosystems that provide integrity guarantees are built upon
\textit{secure permutations}, also known as \textit{block ciphers}. The sender
computes the permutation using an \textit{encryption} algorithm, and the
receiver inverts the permutation using a \textit{decryption} algorithm.
Symmetric key encryption algorithms use the same secret key for encryption and
decryption, while asymmetric key block ciphers use the public key for
encryption, and the corresponding private key for decryption. Secure
permutation functions have the property that an adversary cannot compute the
permutation's inverse without the key used for decryption.

The most popular secure permutation based on symmetric keys at the time of this
writing is the
\textit{American Encryption Standard}~(AES)~\cite{daemen1999aes, fips2001aes},
with two variants that operate on 128-bit blocks using 128-bit keys or 256-bit
keys. Recently, the United States \textit{National Security Agency}~(NSA)
required the use of 256-bit AES keys for protecting sensitive
information~\cite{nsa2015suiteb}.

The most deployed asymmetric key secure permutation is the
\textit{Rivest-Shamir-Adelman}~(RSA)~\cite{rivest1978rsa} algorithm. RSA has
variable key sizes, and 3072-bit key pairs are considered to provide the same
security as 128-bit AES keys~\cite{fips2012keysize}. Recently, elliptic curve
cryptography (ECC)~\cite{koblitz1987ecc} has gained a surge in popularity,
thanks to its smaller key sizes. For example, a 384-bit ECC key is considered
to have the same security as a 3072-bit RSA
key~\cite{fips2012keysize, nsa2015suiteb}.

A cryptographically secure permutation is not enough to ensure privacy. An easy
to see issue is that in our previous example, a permutation would encrypt all
of Alice's \textsc{buy} orders to the same value. Furthermore, each secure
permutation algorithm has its own assumptions that can lead to subtle
vulnerabilities if the algorithm is used directly.

Symmetric key secure permutations are combined with operating modes to form
symmetric encryption schemes. Most operating modes require a random
\textit{initialization vector} (IV) to be used for each message, as shown in
Figure~\ref{fig:symmetric_encryption}. When analyzing the security of systems
based on these cryptosystems, an understanding of the IV generation process is
as important as ensuring the confidentiality of the encryption key. Counter
(CTR) and Cipher Block Chaining (CBC) are examples of operating modes
recommended~\cite{fips2001ctr} by the United States \textit{National Institute
of Standards and Technology}~(NIST), which informs the NSA's requirements.

\begin{figure}[hbt]
  \centering
  \includegraphics[width=85mm]{figures/symmetric_encryption.pdf}
  \caption{
    In a symmetric key encryption scheme, the same secret key must be provided
    to both the encryption and the decryption algorithm. A random
    initialization vector (IV) must be generated for each message.
  }
  \label{fig:symmetric_encryption}
\end{figure}




Asymmetric encryption algorithms have much higher computational requirements
than symmetric encryption algorithms. Therefore, when non-trivial quantities of
data is encrypted, the sender generates a single-use secret key that is used
to encrypt the data, and encrypts the secret key with the receiver's public
key, as shown in Figure~\ref{fig:asymmetric_encryption}.

\begin{figure}[hbt]
  \centering
  \includegraphics[width=87mm]{figures/asymmetric_encryption.pdf}
  \caption{
    In the asymmetric key setting, the encryption algorithm operates on a
    public key, and the decryption algorithm uses the corresponding private
    key. Asymmetric key encryption is generally used to bootstrap a symmetric
    key encryption scheme.
  }
  \label{fig:asymmetric_encryption}
\end{figure}




\subsubsection{Integrity}

Many cryptosystems that provide integrity guarantees are built upon
\textit{cryptographically strong hashing} functions. These hash functions
operate on an unbounded amount of input data and produce a small fixed-size
output. Cryptographically strong hash functions have a few guarantees, such as
\textit{pre-image resistance}, which states that an adversary cannot produce
input data corresponding to a given hash output. The most popular cryptographic
hash function at the time of this writing is the
\textit{Secure Hashing Algorithm}~(SHA)~\cite{eastlake2001sha1}.

In the symmetric key setting, integrity guarantees are typically obtained using
an \textit{Hash Message Authentication Code}~(HMAC)~\cite{krawczyk1997hmac}
construction that combines a symmetric encryption algorithm, like AES, with a
cryptographically secure hash function, such as SHA. The message sender runs
the HMAC algorithm and sends the output HMAC value along with the original
message, as shown in Figure~\ref{fig:symmetric_hmac}. The message receiver
verifies that the received HMAC value is the same as the output of running the
HMAC algorithm on the message. HMAC algorithms inherit the pre-image resistance
property from their underlying cryptographic hash functions, and have the
additional property that an adversary cannot produce the correct HMAC for a
message without the secret key.

\begin{figure}[hbt]
  \centering
  \includegraphics[width=87mm]{figures/symmetric_hmac.pdf}
  \caption{
    In the symmetric key setting, integrity is assured by computing a
    Hash-bassed Message Authentication Code (HMAC) and transmitting it over the
    network along the message. The receiver re-computes the HMAC and compares
    it against the version received from the network.
  }
  \label{fig:symmetric_hmac}
\end{figure}

Asymmetric key primitives that provide integrity guarantees are known as
\textit{signatures}. The message sender provides the private key to a
\textit{signing} algorithm, and transmits the output signature along with the
message, as shown in Figure~\ref{fig:asymmetric_signing}. The message receiver
feeds the public key and the signature to a \textit{signature verification}
algorithm, which returns \textsc{true} if the message matches the signature,
and \textsc{false} if the message has been tampered with.

\begin{figure}[hbt]
  \centering
  \includegraphics[width=87mm]{figures/asymmetric_signing.pdf}
  \caption{
    Signature schemes guarantee integrity in the asymmetric key setting.
    Signatures are created using the sender's private key, and are verified
    using the corresponding public key. A cryptographically secure hash
    function is usually employed to reduce large messages to small hashes,
    which are then signed.
  }
  \label{fig:asymmetric_signing}
\end{figure}

Signing algorithms can only operate on small messages and are computationally
expensive. Therefore, in practice, the message to be transmitted is first ran
through a cryptographically strong hash function, and the hash is provided as
the input to the signing algorithm.

At the time of this writing, the most popular choice for providing encryption
in shared secret settings is a SHA-based HMAC function.

A symmetric key primitive that has been gaining popularity is AES-GCM, which
offers both privacy and integrity guarantees by combining the AES encryption
algorithm with the \textit{Galois/Counter operation
mode}~(GCM)~\cite{mcgrew2004gcm}. AES-GCM has earned NIST's
recommendation~\cite{fips2017gcm}.

The most popular signature algorithm is based on the RSA algorithm. The NSA
requires the Digital Signature Standard (DSS)\cite{fips2013dss}, which
specifies schemes based on RSA and on ECC.


\subsubsection{Freshness}

Freshness guarantees are typically built on top of a system that already offers
integrity guarantees, by adding a unique piece of information to each message.
The main challenge in freshness schemes comes down to economically maintaining
the state needed to generate the unique pieces of information on the sender
side, and verify their uniqueness on the receiver side.

A popular solution for gaining freshness guarantees relies on \textit{nonces},
single-use random numbers. The attractiveness of nonces is that the sender does
not need to maintain any state, but the downside is that the receiver must
store the nonces of all received messages.

Nonces are often combined with a message timestamping and expiration scheme.
This can greatly reduce the receiver's storage requirement, as the nonces for
expired messages can be safely discarded.

