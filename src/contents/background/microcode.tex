\subsection{CPU Microcode}
\label{sec:microcode}

Intel's SGX patents disclose that all the SGX features, except for DRAM
encryption, were implemented as microcode extensions. The limitations of
microcode can explain seemingly arbitrary decisions in the SGX design, and a
good understanding of what can be done in microcode is crucial to evaluating
the feasibility of modification proposals for architectural features such as
SGX.

The first sub-section below presents the relevant facts pertaining to microcode
in Intel's optimization reference \cite{intel2014optimization} and SDM. The
following subsections summarize information gleamed from Intel's patents and
other researchers' findings.


\subsubsection{The Role of Microcode}
\label{sec:microcode_role}

% IntelÂ® Microarchitecture Code Name Sandy Bridge Pipeline Overview:
%     Optimization S 2.2.1
% The Front End: Optimization S 2.2.2

The x86 architecture defines a \textit{complex instruction set} (CISC).
However, virtually all modern CPUs are architected following \textit{reduced
instruction set} (RISC) principles. This is accomplished by having the
instruction decode stage (see Figure~\ref{fig:cpu_core}) break down each x86
instruction into \textit{micro-ops} for every instruction. The other CPU stages
work exclusively with micro-ops.

% Legacy Decode Pipeline (Instruction Decode): Optimization S 2.2.2.1
% Instruction Decode: Optimization S 2.3.2.4
% Front End Overview: Optimization S 2.4.2
% Understanding the Sources of the Micro-Op Queue: SDM S B.3.7.2

The majority of x86 instructions are handled by the hardware decoding path,
which can emit at most 4 micro-ops per instruction. Instructions that require
more than 4 micro-ops use a slower decoding path that relies on a sequencer to
read micro-ops from a \textit{microcode store ROM} (MSROM).

% Assists: Optimization S B.3.5.2

Some operations handle common cases in a fast path backed by hardware. When
an input cannot be handled by the fast path, these operations issue a
\textit{microcode assist}, which points the microcode sequencer to a routine in
microcode that handles the edge cases. The most common cited example is
floating point instructions, which issue assists to handle denormal inputs.

The \texttt{REP MOVS} family of instructions, also known as \textit{string
instructions} because they are often used in \texttt{strcpy}-like functions,
operate on variable-sized arrays. These instructions can handle small arrays in
hardware, and issue microcode assists for larger arrays.

% Microcode Update Facilities: SDM S 9.11
% Responsibilities of the BIOS: SDM 9.11.8.1

Modern Intel processors implement a microcode update facility. The SDM
describes microcode updates from the perspective of an OS kernel and
hypervisor. Each core can be updated independently, and the updates must be
re-applied on each boot cycle. A core can be updated multiple times, but each
update must have a bigger version than the core's current version. The latest
SDM at the time of this writing states that a microcode update is up to 16 kB
in size.

Processor engineers prefer to build new architectural features as microcode
extensions, because microcode can be iterated on much faster than hardware,
which reduces development cost \cite{intel2008genetic, intel2012clusters}. The
update facility further increases the appeal of microcode, as some classes of
bugs can be fixed after a CPU has been released.

The SGX enclave measurements produced by the processor include the microcode
version, hinting that SGX uses microcode in its implementation, and that its
designers anticipated a need to use microcode updates.

In order to be able to evaluate the feasibility our proposed SGX modifications,
we aim to understand the role of microcode in SGX's implementation.
Unfortunately, Intel's SGX documentation does not describe its use of
microcode, so we rely on public information about the role of microcode in the
areas impacted by SGX, namely memory management (\S~\ref{sec:paging},
\S~\ref{sec:tlbs}) and the handling of hardware exceptions
(\S~\ref{sec:faults}) and interrupts (\S~\ref{sec:interrupts}).

% Precise Event Based Sampling (PEBS): SDM S 18.7.1.1
% At-Retirement Counting: SDM S 18.13.6
% Performance Monitoring Events for the 4th Generation Intel Core Processors:
%     SDM S 19.3

The use of microcode assists can be measured using the
\textit{Precise Event Based Sampling} (PEBS) feature in recent Intel
processors. PEBS provides counters for the number of micro-ops coming from
MSROM, including complex instructions and assists, counters for the numbers of
assists associated with some micro-op classes (SSE and AVX stores and
transitions), and a counter for assists generated by all other micro-ops.

The PEBS feature uses microcode assists (this is implied in the SDM and
confirmed by \cite{intel2014pebs}) when it needs to write the execution context
into a PEBS record. Given the wide range of features monitored by PEBS
counters, we assume that all execution units in the core can issue microcode
assists, which are performed at micro-op retirement (confirmed by
\cite{intel1997events}).

% Conditional SIMD Packed Loads and Stores: Optimization S 11.9

Intel's optimization manual describes one more interesting assist, from a
memory system perspective. SIMD masked loads (using \texttt{VMASKMOV}) read a
series of data elements from memory into a vector register. A mask register
decides whether elements are moved or ignored. If the memory address overlaps
an invalid page (e.g., the P flag is 0, S~\ref{sec:paging}), a microcode assist
is issued, even if the mask indicates that no element from the invalid page
should be read. The microcode checks whether the elements in the invalid page
have the corresponding mask bits set, and either performs the load or issues a
page fault.

% IA32_MCG Extended Machine Check State MSRs: SDM S 15.3.2.6

The description of machine checks in the SDM mentions page assists and page
faults in the same context. We assume that the page assists are issued in some
cases when a TLB miss occurs (\S~\ref{sec:tlbs}) and the PMH has to walk the
page table. The following sections develop this assumption and provide
supporting evidence from Intel's published patents.


\subsubsection{Microcode Implementation Details}

% Arch feature implementation strategy
%   US 8,447,962 - 11:39-43, 12:8-13

According to a 2013 patent \cite{intel2013scattergather}, the avenues
considered for implementing new architectural features are a completely
microcode-based implementation, using existing micro-ops, a microcode
implementation with hardware support, which would use new micro-ops, and a
complete hardware implementation, using finite state machines (FSMs).

% Micro-ops table
%   US 7,451,121 - 1:23-25, 1:34-35, 2:64-65
%   US 8,099,587 - 3:1
% Microcode compression
%   US 7,451,121 - Abstract 1 and 10
%   US 8,099,587 - Abstract 1-3 and 7-10, 8:36-49, 11:10-17

The main component of the MSROM is a table of micro-ops \cite{intel2008genetic,
intel2012clusters}. According to an example in a 2012 Intel patent
\cite{intel2012clusters}, the table contains on the order of 20,000 micro-ops,
and a micro-op has about 70 bits. On embedded processors, like the Atom,
microcode may be partially compressed
\cite{intel2008genetic, intel2012clusters}.

% Event ROM
%   US 5,889,982 - 16:57-63, 16:66-17:3
% Microcode handles exceptions:
%   US 5,987,600 - 2:39-57, 4:13-27, 4:39-53, 4:65-5:6, 8:42-58, 10:54-60,
%                  11:18-42, 12:11-17, 12:54-58, 15:46-48, 15:59-62
%   US 5,889,982 - 11:40-42, 11:44-46
%   US 7,213,511 - 8:45-46, 8:49-51,
% Microcode handles traps:
%   US 5,987,600 - 15:16-18, 15:36-40
% Microcode handles interrupts:
%   US 5,987,600 - 16:2-5, 16:18-21
% Microcode handles events (exceptions and assists):
%   US 5,889,982 - 9:23-25, 9:34-42, 15:7-11, 15:27-55, 16:34-38, 16:57-17:3
%   US 5,625,788 - 1:10-12, 1:64-2:133:2-7, 6:31-38, 6:53-7:2, 8:27-47, 9:2-18,
%                  11:60-12:1, 12:4-8, 12:10-15, 12:19-12:22, 12:25-42,
%                  14:12-32

The MSROM also contains an event ROM, which is an array of pointers to event
handling code in the micro-ops table \cite{intel1999events}. Microcode events
are hardware exceptions, assists, and interrupts \cite{intel1997events,
intel1999exceptions}. The processor described in a 1999 patent
\cite{intel1999events} had a 64-entry event table, where the first 16 entries
pointed to hardware exception handlers and the other entries were used by
assists.

% Microcode implementation details:
%   US 5,987,600 - 5:39-49, 5:53-6:32, 5:35-39, 5:42-53, 11:53-60, 11:64-67,
%                  12:6-10, 12:41-45, 14:15-19
%   US 5,680,565 - 2:53-56
%   US 5,889,982 - 6:49-65, 7:8-12, 10:11-14, 13:16-20,
%   US 7,231,511 - 1:49-60, 2:1-8, 2:34-42, 3:2-5, 3:22-40, 5:26-67, 6:1-20
%   US 5,636,374 - 2:47-52, 2:63-3:10, 4:39-45

The execution units can issue an assist or signal a fault by associating an
event code with the result of a micro-op. When the micro-op is committed, the
event code causes the scheduler to squash all future instructions. The event
code is forwarded to the microcode sequencer, which reads the micro-ops in the
event handler \cite{intel1997events, intel1999exceptions}.

The handling of hardware exceptions and interrupts by microcode makes it
possible to change the Intel architecture's behavior when faced with hardware
exceptions and interrupts. The SGX implementation takes advantage of this, as
it modifies the handling of exceptions and interrupts that occur while
executing code inside an enclave.


\subsubsection{Microcode and Address Translation}

% Microcode handles memory exceptions (#PF):
%   US 5,987,600 - 14:26-49, 14:55-61, 14:66-15:3
%   US 5,680,565 - 11:29-37,
%   US 5,889,982 - 14:41-43, 15:47-51,
% Microcode handles DTLB and PMH exceptions:
%   US 5,564,111 - Abstract 15-21, 1:46-59, 3:25-45, 7:47-53, 9:33-51,
%                  10:45-54, 10:57-63
% Microcode performs assisted PMH walk
%   US 5,680,565 - Abstract 1-2 and last 3 lines, 4:9-19, 4:22-28, 12:24-25,
%                  13:42-44, 13:48-54, 13:59-64, 14:12-21, 14:23-29, 14:61-66,
%                  15:1-12, 15:16-39

When a TLB miss (\S~\ref{sec:tlbs}) occurs, the memory execution unit forwards
the linear address to the \textit{Page Miss Handler} (PMH), which performs the
page walk needed to obtain a physical address. The


\cite{intel1999events} explicitly mentions
page faults (\#PF) as an example of an exception, and the PMH-issued microcode
assist used to set accessed and dirty bits in the page tables.

Page faults (\#PF) are a kind of hardware exception, therefore they are handled
by microcode.



% PMH implementation (stuffed loads)
%   US 5,680,565 - 2:60-3:3, 3:25-28, 3:33-52, 3:56, 3:58-4:4, 11:17-21,
%                  11:45-48, 11:50-52, 12:30-34, 12:20-22, 12:40-43, 13:20-22,
%                  14:42-58, 15:54-57
%   US 5,636,374 - 5:59-64, 6:5-8

% DTLB implementation
%   US 5,564,111 - 1:26-29, 1:36-38, 3:7-21, 3:58-60, 5:36-41, 5:48-57,
%                  6:51-52, 6:55-7:7, 7:16-18, 7:23-24, 8:3-8, 8:39-40,
%                  9:66-10:4, 10:16-23

% Microcode initializes the CPU
%   US 8,806,104 - 4:36-41

% Microcode used when vAPIC memory checks fail
%   US 8,806,104 - 2:38-55, 3:12-17, 3:21-35, 3:39-43, 4:6-10, 4:29-42,
%                  4:55-57, 5:6-7, 5:10-17, 5:37-53, 5:58-60, 6:16-19,
%                  7:45-47, 8:30-36, 9:12-15

% Microcode used for VMX instructions
%   US 8,806,104 - 2:61-66

% Microcode encryption
%   US 8,296,528 - 5:12-19

% Microcode sequesters cache ways
%   US 8,296,528 - 6:28-46, 7:9-347:48-51, 7:61-8:10, 8:12-57

% Microcode has microinstruction pointer stack
%   US 7,231,511 - Abstract 1-6, 2:44-45, 2:53-55, 3:9-16, 6:1-3, 12:2-9

% Microcode uses special loads / stores
%   US 5,636,374 - 2:31-36, 2:39-46, 6:10-19, 6:22-25, 6:53-57, 6:62-67,
%                  7:59-60, 8:13-24, 10:61-62, 10:65-12:64

% Microcode can prevent PMH writes
%   US 7,552,255 - 7:52-55

% Microcode gets executed on CR3
%   US 7,552,255 - 8:43-46

% Microcode runs at CPU reset and hashes an ACM in the firmware
%   US 8,321,931 - 6:47-52, 11:39-43, 11:45-47, 11:52-57, 12:6-11
%   US 8,301,907 - 4:8-10, 5:4-11, 5:16-17

% Microcode handles SIPI
%   US 8,301,907 - 4:31-33

\cite{intel1997pmh} describes the operation of the PMH (\S~\ref{sec:tlbs}), and
discloses that the PMH uses a microcode assist when it needs to set the dirty
or accessed bits in a page table (\S~\ref{sec:paging}).

\cite{intel1996dtlb} confirms that microcode is used to handle faults and
assists generated by the TLB (\S~\ref{sec:tlbs}) and PMH.

At the time of this writing, \cite{intel1997events, intel1999exceptions,
intel1997pmh, intel1999events, intel1996dtlb} are 7-8 years old, so there is a
chance that their information is outdated. Fortunately, a recent patent on APIC
virtualization \cite{intel2014vapic} describes a memory execution unit
modification that checks memory accesses against a set of range registers, and
invokes a microcode assist when the accesses don't match.
\cite{intel2014vapic} also mentions that microcode initializes the CPU.

% VGATHER* / VSCATTER* - SDM instruction reference
% Microcode assists used for difficult cases in gather
%   US 8,688,962 - 5:26-30
% Scatter / gather implemented in microcode and hardware
%   US 8,447,962 - 11:28-30, 12:15-17, 12:20-23, 12:25-28


Recently introduced scatter / gather instructions use dedicated hardware in the
\textit{Memory Execution Unit} (MEU) \cite{intel2013scattergather,
intel2014gather}. The MEU, which includes the PMH, triggers a microcode assist
when encountering a complex operation, such as a read from un-cacheable memory
or a page fault \cite{intel2014gather}.

\cite{intel2007microstack} discloses that microcode uses dedicated call and
returnÂ micro-ops that manage a hardware stack structure compatible with out of
order execution. It mentions the handling of traps, faults and assists.

\cite{intel1997microspace} discloses that microcode uses special load and store
instructions, which turn into special bus cycles, to issue commands to other
functional units. The linear addresses of the loads and stores encode commands
and some input parameters. For example, stores to a certain range of addresses
flush specific sets in the TLB.

\cite{intel2009pipeline} discloses that microcode is used when the CR3 register
(\S~\ref{sec:paging}) is set. It also explains that microcode is invoked after
a PMH walk, and can prevent the resulting translation from being written to the
TLB.

Microcode performs the processor's hardware initialization
(\S~\ref{sec:cpu_init}). The SDM states that the BIST is performed by
microcode. On some systems, microcode also authenticates the boot firmware
\cite{intel2012uefihypervisor} before executing it. On systems that use
LaGrande Server Extensions (LT-SX, also known as Intel TXT for servers), the
hardware initialization microcode checks Intel's signature on the motherboard's
firmware and assures the motherboard that the CPU is compatible with LT-SX
\cite{intel2012ltsx}. The microcode in the SIPI (\S~\ref{sec:firmware_boot})
handler sets up a secure environment matching the other CPUs.

\cite{intel2012patching} discloses that microcode updates are encrypted, hashed
with a cryptographic hash function like SHA-256, and signed using RSA or
ellipic curve cryptography. It also states that the decryption and signature
verification are implemented in microcode.

\cite{hawkes2012microcode} independently used fault injection and timing
analysis to conclude that each recent Intel microcode update is signed with a
2048-bit RSA key and a (possibly non-standard) 256-bit hash algorithm, which
agrees with the findings above.

This
implies that Intel already has a microcode implementation of RSA-2048 signature
checking, which may explain why SGX uses RSA signatures in its enclave
structures.

\cite{chen2014microcode} sets out to analyze the structure of microcode used in
all x86 processors, but is unable to obtain any details about Intel's
microcode. Fortunately, even though the microcode structure is undocumented,
the 4 micro-ops limitation can be used to guess intelligently whether an
architectural feature is implemented in microcode. For example, it is safe to
assume that \texttt{XSAVE} (\S~\ref{sec:registers}), which was takes over 200
micro-ops on recent CPUs \cite{fog2014microops}, is most likely performed in
microcode, whereas simple arithmetic and memory access is handled directly by
hardware.

While Intel publishes the latest microcode versions for its CPUs, the release
notes associated with the updates are not publicly available. This is
unfortunate, as the release notes could be used to confirm guesses that certain
features are implemented in microcode. However, some information can be
inferred by reading through the Errata section in Intel's Specification Updates
\cite{intel2010errata, intel2015errata, intel2015errata2}. The phrase ``it is
possible for BIOS\footnote{Basic Input/Output System (BIOS)
is the predecessor of UEFI-based firmware. Most Intel documentation, including
the SDM, still uses the term BIOS to refer to firmware.} to contain a
workaround for this erratum'' generally means that a microcode update was
issued. For example, Errata AH in \cite{intel2010errata} implies that string
instructions (\texttt{REP MOV}) are implemented in microcode, which was
confirmed by Intel \cite{abraham2006repmov}.

Errata AH43 and AH91 in \cite{intel2010errata}, and AAK73 in
\cite{intel2015errata} imply that address translation (\S~\ref{sec:paging}) is
at least partially implemented in microcode. Errata AAK53, AAK63, and AAK70,
AAK178 in \cite{intel2015errata}, and BT138, BT210,  in \cite{intel2015errata2}
imply that VM entries and exits (\S~\ref{sec:faults}) are implemented in
microcode.
