\HeadingLevelB{Misconceptions about SGX}
\label{sec:sgx_misconceptions}

This section sets out to disprove a few common misconceptions about SGX and its
programming model. First, we dispute Intel's non-explicit claims that SGX's
vulnerability to software side-channel attacks is inconsequential. Second, we
dispute commonly voiced concerns that might be used by Intel to justify its
licensing scheme.


\HeadingLevelC{Software Side-Channel Attacks and SGX}

The SGX design reuses a few terms from the Trusted Platform
Module~(TPM,~\S~\ref{sec:sgx_related_tpm}) design. This helps software
developers familiar with TPM understand SGX faster. At the same time, the term
reuse invites the assumption that SGX's software attestation is implemented in
tamper-resistant hardware, similarly to the TPM design.

\S~\ref{sec:sgx_attestation} explains that, in fact, the SGX design delegates
the creation of attestation signatures to software that runs inside a
Quoting Enclave with special privileges that allows it to access the
processor's attestation key. Re-stated, SGX includes an enclave whose
software reads the attestation key and produces attestation signatures.

Creating the Quoting Enclave is a very elegant way of reducing the complexity
of the hardware implementation of SGX, assuming that the isolation guarantees
provided by SGX are sufficient to protect the attestation key. However, the
security analysis in \S~\ref{sec:sgx_security_analysis} reveals that enclaves
are vulnerable to a vast array of software side-channel attacks, which have
been demonstrated effective in extracting a variety of secrets from isolated
environments.

% ISCA 2015 SGX: Slides 122 - 134

The gaps in the security guarantees provided to enclaves place a large amount
of pressure on Intel's software developers, as they must attempt to implement
the EPID signing scheme used by software attestation without leaking any
information. Intel's ISCA 2015 SGX tutorial slides suggest that the SGX
designers will advise developers to write their code in a way that avoids
data-dependent memory accesses, as suggested in
\S~\ref{sec:cache_timing_workarounds}, and perhaps provide analysis tools that
detect code that performs data-dependent memory accesses.

The main drawback of the approach described above is that it is extremely
cumbersome. \S~\ref{sec:cache_timing_workarounds} describes that, while it may
be possible to write simple pieces of software in such a way that they do not
require data-dependent memory accesses, there is no known process that can
scale this to large software systems. For example, each virtual method call in
an object-oriented language results in data-dependent code fetches.

The ISCA 2015 SGX tutorial slides also suggest that the efforts of removing
data-dependent memory accesses should focus on cryptographic algorithm
implementations, in order to protect the keys that they handle. This is a
terribly misguided suggestion, because cryptographic key material has no
intrinsic value. Attackers derive benefits from obtaining the data that is
protected by the keys, such as medical and financial records.

Some security researchers focus on protecting cryptographic keys because they
are the target of today's attacks. Unfortunately, it is easy to lose track of
the fact that keys are being attacked simply because they are the lowest
hanging fruit. A system that can only protect the keys will have a very small
positive impact, as the attackers will simply shift their focus on the
algorithms that process the valuable information, and use the same software
side-channel attacks to obtain that information directly.

The second drawback of the approach described towards the beginning of this
section is that while eliminating data-dependent memory accesses should
thwart the attacks described in \S~\ref{sec:sgx_vs_memory_mapping_attacks} and
\S~\ref{sec:sgx_vs_cache_timing_attacks}, the measure may not be sufficient to
prevent the hyper-threading attacks described in
\S~\ref{sec:sgx_vs_privileged_sw_attacks}. The level of sharing between the two
logical processors~(LP,~\S~\ref{sec:cpu_core}) on the same CPU core is so high
that it is possible that a snooping LP can learn more than the memory access
pattern from the other LP on the same core.

For example, if the number of cycles taken by an integer ALU to execute a
multiplication or division micro-op~(\S~\ref{sec:out_of_order}) depends on its
inputs, the snooping LP could learn some information about the numbers
multiplied or divided by the other LP. While this may be a simple example, it
is safe to assume that the Quoting Enclave will be studied by many motivated
attackers, and that any information leak will be exploited.
